class AdvancedPenTestSuite {
    constructor() {
        this.activeAttacks = new Set();
        this.stealthOptions = new Set();
        this.vulnerabilities = [];
        this.terminal = document.getElementById('terminal');
        this.progressBar = document.getElementById('progressBar');
        this.initializeMatrix();
        this.initializeEventListeners();
    }
    
    initializeMatrix() {
        const canvas = document.getElementById('matrixCanvas');
        const ctx = canvas.getContext('2d');
        
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        const matrix = "ABCDEFGHIJKLMNOPQRSTUVWXYZ123456789@#$%^&*()*&^%+-/~{[|`]}";
        const matrixArray = matrix.split("");
        
        const fontSize = 10;
        const columns = canvas.width / fontSize;
        const drops = [];
        
        for(let x = 0; x < columns; x++) {
            drops[x] = 1;
        }
        
        function draw() {
            ctx.fillStyle = 'rgba(0, 0, 0, 0.04)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = '#00ff00';
            ctx.font = fontSize + 'px monospace';
            
            for(let i = 0; i < drops.length; i++) {
                const text = matrixArray[Math.floor(Math.random() * matrixArray.length)];
                ctx.fillText(text, i * fontSize, drops[i] * fontSize);
                
                if(drops[i] * fontSize > canvas.height && Math.random() > 0.975) {
                    drops[i] = 0;
                }
                drops[i]++;
            }
        }
        
        setInterval(draw, 35);
    }
    
    initializeEventListeners() {
        // Attack buttons
        document.querySelectorAll('.attack-btn').forEach(btn => {
            btn.addEventListener('click', () => {
                btn.classList.toggle('active');
                const attack = btn.dataset.attack;
                
                if (this.activeAttacks.has(attack)) {
                    this.activeAttacks.delete(attack);
                } else {
                    this.activeAttacks.add(attack);
                }
            });
        });
        
        // Stealth options
        document.querySelectorAll('.stealth-card').forEach(card => {
            card.addEventListener('click', () => {
                card.classList.toggle('active');
                const stealth = card.dataset.stealth;
                
                if (this.stealthOptions.has(stealth)) {
                    this.stealthOptions.delete(stealth);
                } else {
                    this.stealthOptions.add(stealth);
                }
            });
        });
    }
    
    log(message, type = 'info') {
        const line = document.createElement('div');
        line.className = `terminal-line ${type}`;
        line.innerHTML = `[${new Date().toLocaleTimeString()}] ${message}`;
        this.terminal.appendChild(line);
        this.terminal.scrollTop = this.terminal.scrollHeight;
    }
    
    updateProgress(percent) {
        this.progressBar.style.width = percent + '%';
    }
    
    async executeReconnaissance(target) {
        this.log(`üéØ Iniciando reconnaissance em: ${target}`, 'warning');
        this.updateProgress(0);
        
        const attacks = Array.from(this.activeAttacks);
        if (attacks.length === 0) {
            this.log('‚ùå Nenhum m√©todo de reconnaissance selecionado', 'error');
            return;
        }
        
        for (let i = 0; i < attacks.length; i++) {
            const attack = attacks[i];
            this.updateProgress((i / attacks.length) * 100);
            
            switch (attack) {
                case 'subdomain':
                    await this.subdomainEnumeration(target);
                    break;
                case 'portscan':
                    await this.portScanning(target);
                    break;
                case 'whois':
                    await this.whoisLookup(target);
                    break;
                case 'dns':
                    await this.dnsEnumeration(target);
                    break;
                case 'shodan':
                    await this.shodanSearch(target);
                    break;
                case 'social':
                    await this.socialEngineering(target);
                    break;
            }
        }
        
        this.updateProgress(100);
        this.log('‚úÖ Reconnaissance conclu√≠do', 'success');
    }
    
    async subdomainEnumeration(target) {
        this.log(`üîç Enumerando subdom√≠nios de ${target}...`, 'info');
        
        // Simular descoberta de subdom√≠nios
        const commonSubdomains = [
            'www', 'mail', 'ftp', 'admin', 'test', 'dev', 'staging', 'api',
            'blog', 'shop', 'portal', 'secure', 'vpn', 'remote', 'backup',
            'db', 'mysql', 'phpmyadmin', 'cpanel', 'webmail', 'support'
        ];
        
        const foundSubdomains = [];
        
        for (const sub of commonSubdomains) {
            await this.delay(100);
            
            // Simular verifica√ß√£o DNS
            if (Math.random() > 0.7) {
                const subdomain = `${sub}.${target}`;
                foundSubdomains.push(subdomain);
                this.log(`üìç Subdom√≠nio encontrado: ${subdomain}`, 'success');
                
                // Verificar se √© um subdom√≠nio sens√≠vel
                if (['admin', 'test', 'dev', 'staging', 'backup', 'db'].includes(sub)) {
                    this.vulnerabilities.push({
                        type: 'Exposed Sensitive Subdomain',
                        severity: 'high',
                        target: subdomain,
                        description: `Subdom√≠nio sens√≠vel ${subdomain} est√° publicamente acess√≠vel`,
                        impact: 'Poss√≠vel exposi√ß√£o de dados administrativos ou de desenvolvimento',
                        recommendation: 'Restringir acesso ou implementar autentica√ß√£o'
                    });
                }
            }
        }
        
        this.log(`üìä Total de subdom√≠nios encontrados: ${foundSubdomains.length}`, 'warning');
    }
    
    async portScanning(target) {
        this.log(`üîå Escaneando portas de ${target}...`, 'info');
        
        const commonPorts = [
            { port: 21, service: 'FTP' },
            { port: 22, service: 'SSH' },
            { port: 23, service: 'Telnet' },
            { port: 25, service: 'SMTP' },
            { port: 53, service: 'DNS' },
            { port: 80, service: 'HTTP' },
            { port: 110, service: 'POP3' },
            { port: 143, service: 'IMAP' },
            { port: 443, service: 'HTTPS' },
            { port: 993, service: 'IMAPS' },
            { port: 995, service: 'POP3S' },
            { port: 3306, service: 'MySQL' },
            { port: 3389, service: 'RDP' },
            { port: 5432, service: 'PostgreSQL' },
            { port: 6379, service: 'Redis' },
            { port: 27017, service: 'MongoDB' }
        ];
        
        const openPorts = [];
        
        for (const { port, service } of commonPorts) {
            await this.delay(50);
            
            if (Math.random() > 0.6) {
                openPorts.push({ port, service });
                this.log(`üîì Porta aberta: ${port}/${service}`, 'success');
                
                // Verificar portas perigosas
                if ([21, 23, 3306, 3389, 6379, 27017].includes(port)) {
                    this.vulnerabilities.push({
                        type: 'Dangerous Open Port',
                        severity: 'critical',
                        target: `${target}:${port}`,
                        description: `Porta ${port} (${service}) est√° aberta e acess√≠vel`,
                        impact: 'Poss√≠vel acesso n√£o autorizado ao servi√ßo',
                        recommendation: `Fechar porta ${port} ou implementar firewall/autentica√ß√£o`
                    });
                }
            }
        }
        
        this.log(`üìä Total de portas abertas: ${openPorts.length}`, 'warning');
    }
    
    async whoisLookup(target) {
        this.log(`üìã Consultando WHOIS de ${target}...`, 'info');
        await this.delay(1000);
        
        // Simular dados WHOIS
        const whoisData = {
            registrar: 'GoDaddy.com, LLC',
            created: '2015-03-15',
            expires: '2025-03-15',
            nameservers: ['ns1.example.com', 'ns2.example.com'],
            emails: ['admin@' + target, 'tech@' + target]
        };
        
        this.log(`üìÖ Dom√≠nio criado: ${whoisData.created}`, 'info');
        this.log(`üìÖ Expira em: ${whoisData.expires}`, 'info');
        this.log(`üìß Emails encontrados: ${whoisData.emails.join(', ')}`, 'warning');
        
        // Verificar se o dom√≠nio expira em breve
        const expiryDate = new Date(whoisData.expires);
        const now = new Date();
        const daysUntilExpiry = Math.ceil((expiryDate - now) / (1000 * 60 * 60 * 24));
        
        if (daysUntilExpiry < 90) {
            this.vulnerabilities.push({
                type: 'Domain Expiry Risk',
                severity: 'medium',
                target: target,
                description: `Dom√≠nio expira em ${daysUntilExpiry} dias`,
                impact: 'Risco de perda do dom√≠nio por falta de renova√ß√£o',
                recommendation: 'Renovar dom√≠nio antes do vencimento'
            });
        }
    }
    
    async dnsEnumeration(target) {
        this.log(`üåê Enumerando registros DNS de ${target}...`, 'info');
        
        const dnsRecords = ['A', 'AAAA', 'MX', 'TXT', 'CNAME', 'NS', 'SOA'];
        
        for (const record of dnsRecords) {
            await this.delay(200);
            
            if (Math.random() > 0.4) {
                let value = '';
                switch (record) {
                    case 'A':
                        value = `192.168.1.${Math.floor(Math.random() * 255)}`;
                        break;
                    case 'MX':
                        value = `mail.${target}`;
                        break;
                    case 'TXT':
                        value = 'v=spf1 include:_spf.google.com ~all';
                        // Verificar SPF/DKIM
                        if (value.includes('spf1')) {
                            this.log(`üîí SPF configurado: ${value}`, 'success');
                        }
                        break;
                    default:
                        value = `${record.toLowerCase()}.${target}`;
                }
                
                this.log(`üìù ${record}: ${value}`, 'info');
            }
        }
    }
    
    async shodanSearch(target) {
        this.log(`üîç Pesquisando ${target} no Shodan...`, 'info');
        await this.delay(1500);
        
        // Simular resultados do Shodan
        const shodanResults = [
            { ip: '192.168.1.100', port: 80, service: 'nginx/1.18.0', country: 'US' },
            { ip: '192.168.1.101', port: 443, service: 'Apache/2.4.41', country: 'US' },
            { ip: '192.168.1.102', port: 22, service: 'OpenSSH 7.4', country: 'US' }
        ];
        
        for (const result of shodanResults) {
            this.log(`üåç IP: ${result.ip}:${result.port} - ${result.service} (${result.country})`, 'warning');
            
            // Verificar vers√µes desatualizadas
            if (result.service.includes('Apache/2.4.41') || result.service.includes('nginx/1.18.0')) {
                this.vulnerabilities.push({
                    type: 'Outdated Software Version',
                    severity: 'medium',
                    target: `${result.ip}:${result.port}`,
                    description: `Vers√£o desatualizada detectada: ${result.service}`,
                    impact: 'Poss√≠veis vulnerabilidades conhecidas na vers√£o',
                    recommendation: 'Atualizar para vers√£o mais recente'
                });
            }
        }
    }
    
    async socialEngineering(target) {
        this.log(`üë• Coletando informa√ß√µes de OSINT sobre ${target}...`, 'info');
        await this.delay(2000);
        
        // Simular coleta de informa√ß√µes p√∫blicas
        const osintData = {
            employees: ['john.doe@' + target, 'jane.smith@' + target, 'admin@' + target],
            socialMedia: ['LinkedIn', 'Twitter', 'Facebook'],
            technologies: ['WordPress', 'jQuery', 'Google Analytics'],
            breaches: Math.random() > 0.7
        };
        
        this.log(`üë§ Funcion√°rios encontrados: ${osintData.employees.length}`, 'warning');
        osintData.employees.forEach(email => {
            this.log(`üìß Email: ${email}`, 'info');
        });
        
        this.log(`üì± Redes sociais: ${osintData.socialMedia.join(', ')}`, 'info');
        this.log(`üíª Tecnologias: ${osintData.technologies.join(', ')}`, 'info');
        
        if (osintData.breaches) {
            this.vulnerabilities.push({
                type: 'Data Breach History',
                severity: 'high',
                target: target,
                description: 'Dom√≠nio encontrado em bases de dados de vazamentos',
                impact: 'Credenciais podem estar comprometidas',
                recommendation: 'For√ßar reset de senhas e implementar 2FA'
            });
            this.log(`üö® ALERTA: Dom√≠nio encontrado em vazamentos de dados!`, 'error');
        }
    }
    
    async executeVulnerabilityScanning(target) {
        this.log(`üéØ Iniciando scan de vulnerabilidades em: ${target}`, 'warning');
        this.updateProgress(0);
        
        const attacks = Array.from(this.activeAttacks);
        if (attacks.length === 0) {
            this.log('‚ùå Nenhum tipo de scan selecionado', 'error');
            return;
        }
        
        for (let i = 0; i < attacks.length; i++) {
            const attack = attacks[i];
            this.updateProgress((i / attacks.length) * 100);
            
            switch (attack) {
                case 'sqli':
                    await this.sqlInjectionTest(target);
                    break;
                case 'xss':
                    await this.xssTest(target);
                    break;
                case 'lfi':
                    await this.lfiTest(target);
                    break;
                case 'xxe':
                    await this.xxeTest(target);
                    break;
                case 'ssrf':
                    await this.ssrfTest(target);
                    break;
                case 'rce':
                    await this.rceTest(target);
                    break;
            }
        }
        
        this.updateProgress(100);
        this.log('‚úÖ Scan de vulnerabilidades conclu√≠do', 'success');
        this.displayVulnerabilities();
    }
    
    async sqlInjectionTest(target) {
        this.log(`üíâ Testando SQL Injection em ${target}...`, 'info');
        
        const sqlPayloads = [
            "' OR '1'='1",
            "' UNION SELECT 1,2,3--",
            "'; DROP TABLE users--",
            "' AND (SELECT COUNT(*) FROM information_schema.tables)>0--",
            "' OR 1=1 LIMIT 1 OFFSET 0--"
        ];
        
        const vulnerableParams = ['id', 'user', 'search', 'category', 'page'];
        
        for (const param of vulnerableParams) {
            await this.delay(300);
            
            if (Math.random() > 0.8) {
                const payload = sqlPayloads[Math.floor(Math.random() * sqlPayloads.length)];
                this.log(`üéØ Testando: ${param}=${payload}`, 'warning');
                
                // Simular resposta vulner√°vel
                if (Math.random() > 0.7) {
                    this.vulnerabilities.push({
                        type: 'SQL Injection',
                        severity: 'critical',
                        target: `${target}?${param}=${payload}`,
                        description: `Par√¢metro '${param}' vulner√°vel a SQL Injection`,
                        impact: 'Acesso total ao banco de dados, exfiltra√ß√£o de dados',
                        recommendation: 'Usar prepared statements e valida√ß√£o de entrada'
                    });
                    this.log(`üö® VULNERABILIDADE CR√çTICA: SQL Injection em '${param}'`, 'error');
                }
            }
        }
    }
    
    async xssTest(target) {
        this.log(`üî• Testando XSS em ${target}...`, 'info');
        
        const xssPayloads = [
            "<script>alert('XSS')</script>",
            "<img src=x onerror=alert('XSS')>",
            "javascript:alert('XSS')",
            "<svg onload=alert('XSS')>",
            "';alert('XSS');//"
        ];
        
        const xssParams = ['search', 'comment', 'name', 'message', 'title'];
        
        for (const param of xssParams) {
            await this.delay(250);
            
            if (Math.random() > 0.6) {
                const payload = xssPayloads[Math.floor(Math.random() * xssPayloads.length)];
                this.log(`üéØ Testando XSS: ${param}=${payload}`, 'warning');
                
                if (Math.random() > 0.5) {
                    this.vulnerabilities.push({
                        type: 'Cross-Site Scripting (XSS)',
                        severity: 'high',
                        target: `${target}?${param}=${encodeURIComponent(payload)}`,
                        description: `Par√¢metro '${param}' vulner√°vel a XSS`,
                        impact: 'Roubo de cookies, redirecionamento malicioso, defacement',
                        recommendation: 'Sanitizar entrada e implementar CSP'
                    });
                    this.log(`üö® XSS ENCONTRADO em '${param}'`, 'error');
                }
            }
        }
    }
    
    async lfiTest(target) {
        this.log(`üìÅ Testando Local File Inclusion em ${target}...`, 'info');
        
        const lfiPayloads = [
            "../../../etc/passwd",
            "..\\..\\..\\windows\\system32\\drivers\\etc\\hosts",
            "php://filter/read=convert.base64-encode/resource=index.php",
            "/proc/self/environ",
            "../../../var/log/apache2/access.log"
        ];
        
        for (const payload of lfiPayloads) {
            await this.delay(400);
            
            if (Math.random() > 0.8) {
                this.log(`üéØ Testando LFI: ${payload}`, 'warning');
                
                if (Math.random() > 0.6) {
                    this.vulnerabilities.push({
                        type: 'Local File Inclusion (LFI)',
                        severity: 'critical',
                        target: `${target}?file=${payload}`,
                        description: `Poss√≠vel LFI detectado com payload: ${payload}`,
                        impact: 'Leitura de arquivos sens√≠veis do sistema',
                        recommendation: 'Validar e sanitizar par√¢metros de arquivo'
                    });
                    this.log(`üö® LFI CR√çTICO ENCONTRADO!`, 'error');
                }
            }
        }
    }
    
    async xxeTest(target) {
        this.log(`üìÑ Testando XXE Injection em ${target}...`, 'info');
        await this.delay(800);
        
        const xxePayload = `<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>&xxe;</root>`;
        
        if (Math.random() > 0.7) {
            this.vulnerabilities.push({
                type: 'XML External Entity (XXE)',
                severity: 'high',
                target: target,
                description: 'Endpoint vulner√°vel a XXE Injection',
                impact: 'Leitura de arquivos, SSRF, DoS',
                recommendation: 'Desabilitar entidades externas no parser XML'
            });
            this.log(`üö® XXE INJECTION ENCONTRADO!`, 'error');
        }
    }
    
    async ssrfTest(target) {
        this.log(`üåê Testando SSRF em ${target}...`, 'info');
        
        const ssrfPayloads = [
            "http://localhost:80",
            "http://127.0.0.1:22",
            "http://169.254.169.254/latest/meta-data/",
            "file:///etc/passwd",
            "gopher://127.0.0.1:3306"
        ];
        
        for (const payload of ssrfPayloads) {
            await this.delay(300);
            
            if (Math.random() > 0.8) {
                this.log(`üéØ Testando SSRF: ${payload}`, 'warning');
                
                if (Math.random() > 0.6) {
                    this.vulnerabilities.push({
                        type: 'Server-Side Request Forgery (SSRF)',
                        severity: 'high',
                        target: `${target}?url=${payload}`,
                        description: `SSRF detectado com payload: ${payload}`,
                        impact: 'Acesso a recursos internos, bypass de firewall',
                        recommendation: 'Validar e filtrar URLs de entrada'
                    });
                    this.log(`üö® SSRF ENCONTRADO!`, 'error');
                }
            }
        }
    }
    
    async rceTest(target) {
        this.log(`üí• Testando Remote Code Execution em ${target}...`, 'info');
        
        const rcePayloads = [
            "; cat /etc/passwd",
            "| whoami",
            "`id`",
            "$(uname -a)",
            "&& dir"
        ];
        
        for (const payload of rcePayloads) {
            await this.delay(500);
            
            if (Math.random() > 0.9) {
                this.log(`üéØ Testando RCE: ${payload}`, 'warning');
                
                if (Math.random() > 0.8) {
                    this.vulnerabilities.push({
                        type: 'Remote Code Execution (RCE)',
                        severity: 'critical',
                        target: `${target}?cmd=${payload}`,
                        description: `RCE cr√≠tico detectado com payload: ${payload}`,
                        impact: 'Controle total do servidor',
                        recommendation: 'Nunca executar entrada do usu√°rio como c√≥digo'
                    });
                    this.log(`üö® RCE CR√çTICO ENCONTRADO!`, 'error');
                }
            }
        }
    }
    
    displayVulnerabilities() {
        if (this.vulnerabilities.length === 0) {
            this.log('‚úÖ Nenhuma vulnerabilidade cr√≠tica encontrada', 'success');
            return;
        }
        
        this.log(`\nüìä RESUMO DE VULNERABILIDADES ENCONTRADAS:`, 'warning');
        this.log(`‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ`, 'warning');
        
        const severityCount = {
            critical: 0,
            high: 0,
            medium: 0,
            low: 0
        };
        
        this.vulnerabilities.forEach((vuln, index) => {
            severityCount[vuln.severity]++;
            
            this.log(`\n${index + 1}. ${vuln.type} [${vuln.severity.toUpperCase()}]`, 'error');
            this.log(`   Target: ${vuln.target}`, 'info');
            this.log(`   Descri√ß√£o: ${vuln.description}`, 'info');
            this.log(`   Impacto: ${vuln.impact}`, 'warning');
            this.log(`   Recomenda√ß√£o: ${vuln.recommendation}`, 'success');
        });
        
        this.log(`\nüìà ESTAT√çSTICAS:`, 'warning');
        this.log(`üî¥ Cr√≠ticas: ${severityCount.critical}`, 'error');
        this.log(`üü† Altas: ${severityCount.high}`, 'warning');
        this.log(`üü° M√©dias: ${severityCount.medium}`, 'warning');
        this.log(`üü¢ Baixas: ${severityCount.low}`, 'success');
        
        const riskScore = (severityCount.critical * 10) + (severityCount.high * 7) + (severityCount.medium * 4) + (severityCount.low * 1);
        this.log(`\nüéØ SCORE DE RISCO: ${riskScore}/100`, riskScore > 50 ? 'error' : 'warning');
    }
    
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}

// Inst√¢ncia global
const pentestSuite = new AdvancedPenTestSuite();

async function executeRecon() {
    const target = document.getElementById('reconTarget').value.trim();
    if (!target) {
        alert('Digite um alvo v√°lido');
        return;
    }
    
    await pentestSuite.executeReconnaissance(target);
}

async function executeVulnScan() {
    const target = document.getElementById('vulnTarget').value.trim();
    if (!target) {
        alert('Digite uma URL v√°lida');
        return;
    }
    
    await pentestSuite.executeVulnerabilityScanning(target);
}

async function testPayload() {
    const payload = document.querySelector('.payload-input').value.trim();
    if (!payload) {
        alert('Digite um payload para testar');
        return;
    }
    
    pentestSuite.log(`üß™ Testando payload personalizado...`, 'warning');
    pentestSuite.log(`Payload: ${payload}`, 'info');
    
    await pentestSuite.delay(1000);
    
    // Simular teste de payload
    if (Math.random() > 0.5) {
        pentestSuite.log(`‚úÖ Payload executado com sucesso`, 'success');
        pentestSuite.vulnerabilities.push({
            type: 'Custom Payload Test',
            severity: 'high',
            target: 'Custom Target',
            description: 'Payload personalizado executado com sucesso',
            impact: 'Impacto depende do payload utilizado',
            recommendation: 'Analisar resultado e implementar corre√ß√µes'
        });
    } else {
        pentestSuite.log(`‚ùå Payload bloqueado ou falhou`, 'error');
    }
}

function generateReport() {
    const report = {
        timestamp: new Date().toISOString(),
        vulnerabilities: pentestSuite.vulnerabilities,
        summary: {
            total: pentestSuite.vulnerabilities.length,
            critical: pentestSuite.vulnerabilities.filter(v => v.severity === 'critical').length,
            high: pentestSuite.vulnerabilities.filter(v => v.severity === 'high').length,
            medium: pentestSuite.vulnerabilities.filter(v => v.severity === 'medium').length,
            low: pentestSuite.vulnerabilities.filter(v => v.severity === 'low').length
        },
        tool: 'GUNIC Advanced PenTest Suite v2.0'
    };
    
    const blob = new Blob([JSON.stringify(report, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `pentest-report-${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    
    pentestSuite.log(`üìÑ Relat√≥rio gerado e baixado`, 'success');
}